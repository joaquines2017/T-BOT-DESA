// src/flows/statusTicketFlow.ts
import { addKeyword } from '@builderbot/bot';
import { handleGetTicketStatus } from '../controllers/ticketController';

export const flowEstadoTicket = addKeyword(['2'])
    .addAnswer('Por favor, proporciona el ID del ticketğŸ“‹.', { capture: true }) // Usamos `capture: true` para esperar la entrada del usuario
    .addAction(async (ctx, { provider }) => {
        // Capturamos la entrada del usuario y la procesamos
        const userMessage = ctx.body.trim(); // Captura el mensaje y elimina espacios innecesarios
        const issueId = parseInt(userMessage, 10); // Convertimos el mensaje a nÃºmero

        // Validamos que el ID proporcionado sea un nÃºmero vÃ¡lido
        if (isNaN(issueId)) {
            await provider.sendMessage(ctx.from, 'El ID del ticket no es vÃ¡lido ğŸš«. Por favor, proporciona un nÃºmero vÃ¡lido âœ….', {});
            return;
        }

        try {
            // Llamamos al controlador para obtener el estado del ticket desde la API de Redmine
            const status = await handleGetTicketStatus(issueId);
            
            if (status) {
                // Enviamos el estado del ticket al usuario
                await provider.sendMessage(ctx.from, `El estado del ticket es: ${status}`, {});
            } else {
                // Si no se encuentra el ticket
                await provider.sendMessage(ctx.from, 'No se encontrÃ³ ningÃºn ticket con ese ID.', {});
            }
        } catch (error) {
            console.error('Error al consultar el estado del ticket:', error);
            // Enviar un mensaje de error al usuario
            await provider.sendMessage(ctx.from, 'Hubo un problema ğŸš¨ al consultar el estado del ticketğŸ“‹. IntÃ©ntalo de nuevo mÃ¡s tardeğŸ•–.', {});
        }
    });
